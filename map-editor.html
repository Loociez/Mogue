<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Map Editor</title>
  <style>
    body { margin: 0; display: flex; font-family: sans-serif; height: 100vh; }
    #paletteContainer { width: 320px; background: #222; color: white; padding: 10px; overflow-y: auto; }
    #editorWrapper { flex: 1; display: flex; justify-content: center; align-items: center; background: #444; }
    canvas { border: 1px solid black; image-rendering: pixelated; background: #888; }
    #sidebar { width: 300px; background: #333; color: white; padding: 10px; overflow-y: auto; }
    input[type="checkbox"] { margin-right: 5px; }
    label { margin-right: 10px; }
    button { margin: 2px 0; width: 100%; }
  </style>
</head>
<body>
  <div id="paletteContainer">
    <canvas id="paletteCanvas"></canvas>
  </div>

  <div id="editorWrapper">
    <canvas id="editorCanvas" width="1024" height="768"></canvas>
  </div>

  <div id="sidebar">
    <h3>Map Controls</h3>
    <div id="controlsContainer"></div>
  </div>

  <script type="module">
    import { TILE_SIZE, ATTRIBUTE_KEYS } from './js/map.js';

    const canvas = document.getElementById("editorCanvas");
    const ctx = canvas.getContext("2d");

    // --- Tilesets ---
    const tilesetNames = ["tileset","tileset1","tileset2","tileset3","tileset4","tileset5","tileset6","tileset7","tileset8","tileset9","tileset10"]; 
    const tilesetImages = [];
    let tilesetsLoaded = 0;

    tilesetNames.forEach(name => {
      const img = new Image();
      img.src = `assets/${name}.png`;
      img.onload = () => { tilesetsLoaded++; if (tilesetsLoaded === tilesetNames.length) { drawPalette(); draw(); } };
      tilesetImages.push(img);
    });

    let currentTilesetIndex = 0;
    const width = canvas.width / TILE_SIZE;
    const height = canvas.height / TILE_SIZE;

    // --- Map layers ---
    let mapData = {
      ground: Array.from({ length: height }, () => Array(width).fill(null)),
      groundAnim: Array.from({ length: height }, () => Array(width).fill(null)),
      objects: Array.from({ length: height }, () => Array(width).fill(null)),
      objectAnim: Array.from({ length: height }, () => Array(width).fill(null)),
      object2: Array.from({ length: height }, () => Array(width).fill(null)),
      object2Anim: Array.from({ length: height }, () => Array(width).fill(null))
    };

    let currentLayer = "ground";
    let selectedTiles = [[0]]; 
    let currentAttributes = ATTRIBUTE_KEYS.reduce((acc, key) => { acc[key]=false; return acc; }, { walkable:true });
    let lightSource = { color:"#ffffff", brightness:0.5, flicker:false };

    // --- Palette ---
    const TILE_DISPLAY_SIZE = 32;
    const TILES_PER_ROW = 8;
    const paletteCanvas = document.getElementById("paletteCanvas");
    const pctx = paletteCanvas.getContext("2d");

    function drawPalette() {
      const tileset = tilesetImages[currentTilesetIndex];
      if (!tileset.complete) return;
      const tilesAcrossInImage = Math.floor(tileset.width / TILE_SIZE);
      const totalTiles = tilesAcrossInImage * Math.floor(tileset.height / TILE_SIZE);
      const tilesAcross = TILES_PER_ROW; 
      const tilesHigh = Math.ceil(totalTiles / tilesAcross);
      paletteCanvas.width = tilesAcross * TILE_DISPLAY_SIZE;
      paletteCanvas.height = tilesHigh * TILE_DISPLAY_SIZE;
      pctx.clearRect(0, 0, paletteCanvas.width, paletteCanvas.height);

      for (let i = 0; i < totalTiles; i++) {
        const sx = (i % tilesAcrossInImage) * TILE_SIZE;
        const sy = Math.floor(i / tilesAcrossInImage) * TILE_SIZE;
        const dx = (i % tilesAcross) * TILE_DISPLAY_SIZE;
        const dy = Math.floor(i / tilesAcross) * TILE_DISPLAY_SIZE;
        pctx.drawImage(tileset, sx, sy, TILE_SIZE, TILE_SIZE, dx, dy, TILE_DISPLAY_SIZE, TILE_DISPLAY_SIZE);
      }

      pctx.strokeStyle = "red";
      pctx.lineWidth = 2;
      selectedTiles.forEach(row => row.forEach(tileId => {
        const selX = (tileId % tilesAcross) * TILE_DISPLAY_SIZE;
        const selY = Math.floor(tileId / tilesAcross) * TILE_DISPLAY_SIZE;
        pctx.strokeRect(selX, selY, TILE_DISPLAY_SIZE, TILE_DISPLAY_SIZE);
      }));
    }

    let paletteDragging = false;
    let multiSelectStart = null;
    paletteCanvas.addEventListener("mousedown", e => {
      paletteDragging = true;
      const tile = getTileFromPalette(e);
      if (!tile) return;
      if (!e.shiftKey) selectedTiles = [[tile]]; 
      multiSelectStart = {x: tile % TILES_PER_ROW, y: Math.floor(tile / TILES_PER_ROW)};
      handlePaletteDrag(e);
    });
    paletteCanvas.addEventListener("mousemove", e => { if(paletteDragging) handlePaletteDrag(e); });
    paletteCanvas.addEventListener("mouseup", e => { paletteDragging=false; multiSelectStart=null; drawPalette(); });
    paletteCanvas.addEventListener("mouseleave", e => { paletteDragging=false; multiSelectStart=null; drawPalette(); });

    function getTileFromPalette(e){
      const rect = paletteCanvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left)/TILE_DISPLAY_SIZE);
      const y = Math.floor((e.clientY - rect.top)/TILE_DISPLAY_SIZE);
      if(x<0 || y<0) return null;
      return y * TILES_PER_ROW + x;
    }

    function handlePaletteDrag(e){
      if(!multiSelectStart) return;
      const endTile = getTileFromPalette(e);
      if(!endTile) return;
      const startX = multiSelectStart.x;
      const startY = multiSelectStart.y;
      const endX = endTile % TILES_PER_ROW;
      const endY = Math.floor(endTile / TILES_PER_ROW);
      const minX = Math.min(startX, endX);
      const maxX = Math.max(startX, endX);
      const minY = Math.min(startY, endY);
      const maxY = Math.max(startY, endY);
      const newSelection = [];
      for(let y=minY;y<=maxY;y++){
        const row=[];
        for(let x=minX;x<=maxX;x++){ row.push(y * TILES_PER_ROW + x); }
        newSelection.push(row);
      }
      selectedTiles = newSelection;
      drawPalette();
    }

    // --- Sidebar controls ---
    const controlsDiv = document.getElementById("controlsContainer");

    // Tileset selector
    controlsDiv.appendChild(document.createTextNode("Tileset: "));
    const tilesetSelect = document.createElement("select");
    tilesetSelect.style.width="150px";
    tilesetNames.forEach((name,i)=>{ const opt=document.createElement("option"); opt.value=i; opt.text=name; tilesetSelect.appendChild(opt); });
    tilesetSelect.onchange=()=>{ currentTilesetIndex=parseInt(tilesetSelect.value); drawPalette(); };
    controlsDiv.appendChild(tilesetSelect); controlsDiv.appendChild(document.createElement("br"));

    // Layer selector
    controlsDiv.appendChild(document.createTextNode("Layer: "));
    const layerSelect = document.createElement("select");
    ["ground","groundAnim","objects","objectAnim","object2","object2Anim"].forEach(layer=>{ const opt=document.createElement("option"); opt.value=layer; opt.text=layer; layerSelect.appendChild(opt); });
    layerSelect.onchange=()=>currentLayer=layerSelect.value;
    controlsDiv.appendChild(layerSelect); controlsDiv.appendChild(document.createElement("br"));

    // Attributes
    ATTRIBUTE_KEYS.forEach(attr=>{
      const chk=document.createElement("input"); chk.type="checkbox"; chk.id=attr;
      chk.onchange=()=>currentAttributes[attr]=chk.checked;
      const lbl=document.createElement("label"); lbl.innerText=attr; lbl.htmlFor=attr;
      controlsDiv.appendChild(chk); controlsDiv.appendChild(lbl); controlsDiv.appendChild(document.createElement("br"));
    });

    // Light controls
    const lightSection=document.createElement("div"); lightSection.appendChild(document.createTextNode("Light:")); lightSection.appendChild(document.createElement("br"));
    const lightChk=document.createElement("input"); lightChk.type="checkbox"; lightChk.onchange=()=>currentAttributes.light=lightChk.checked;
    lightSection.appendChild(lightChk); lightSection.appendChild(document.createTextNode("Enable Light")); lightSection.appendChild(document.createElement("br"));
    const lightColorInput=document.createElement("input"); lightColorInput.type="color"; lightColorInput.value=lightSource.color;
    lightColorInput.onchange=()=>lightSource.color=lightColorInput.value; lightSection.appendChild(document.createTextNode("Color:")); lightSection.appendChild(lightColorInput); lightSection.appendChild(document.createElement("br"));
    const brightnessInput=document.createElement("input"); brightnessInput.type="range"; brightnessInput.min=0; brightnessInput.max=1; brightnessInput.step=0.01; brightnessInput.value=lightSource.brightness;
    brightnessInput.oninput=()=>lightSource.brightness=parseFloat(brightnessInput.value); lightSection.appendChild(document.createTextNode("Brightness:")); lightSection.appendChild(brightnessInput); lightSection.appendChild(document.createElement("br"));
    const flickerChk=document.createElement("input"); flickerChk.type="checkbox"; flickerChk.onchange=()=>lightSource.flicker=flickerChk.checked;
    lightSection.appendChild(document.createTextNode("Flicker:")); lightSection.appendChild(flickerChk); lightSection.appendChild(document.createElement("br"));
    controlsDiv.appendChild(lightSection);

    // --- Weather controls ---
    const weatherSection = document.createElement("div");
    weatherSection.appendChild(document.createTextNode("Weather: ")); weatherSection.appendChild(document.createElement("br"));
    const weatherSelect = document.createElement("select");
    ["default","none","rain"].forEach(optText => { 
        const opt = document.createElement("option"); 
        opt.value = optText; 
        opt.text = optText; 
        weatherSelect.appendChild(opt); 
    });
    weatherSection.appendChild(weatherSelect); 
    controlsDiv.appendChild(weatherSection);

    let weather = { type: "none", intensity: 100, rainDrops: [] };
    const rainImage = new Image();

    weatherSelect.onchange = () => {
      weather.type = weatherSelect.value;
      if(weather.type === "rain") {
        rainImage.src = "assets/rain.png";
        initRain();
      } else {
        weather.rainDrops.length = 0;
      }
      draw();
    };

    function initRain() {
      weather.rainDrops.length = 0;
      for(let i=0;i<weather.intensity;i++){
        weather.rainDrops.push({
          x: Math.random()*canvas.width,
          y: Math.random()*canvas.height,
          length: 10+Math.random()*10,
          speed: 4+Math.random()*4
        });
      }
    }

    function updateRain() {
      if(weather.type !== "rain") return;
      for(const drop of weather.rainDrops){
        drop.y += drop.speed;
        drop.x += Math.sin(drop.y*0.05)*2;
        if(drop.y > canvas.height){ drop.y = -drop.length; drop.x = Math.random()*canvas.width; }
      }
    }

    function drawWeather() {
      if(weather.type !== "rain") return;
      updateRain();
      ctx.strokeStyle = "rgba(173,216,230,0.5)";
      ctx.lineWidth = 1;
      for(const drop of weather.rainDrops){
        ctx.beginPath();
        ctx.moveTo(drop.x, drop.y);
        ctx.lineTo(drop.x + drop.length*0.2, drop.y + drop.length);
        ctx.stroke();
      }
    }

    // --- Action buttons ---
    ["Fill Layer","Clear Layer","Export Map","Load Map"].forEach(text=>{
      const btn=document.createElement("button"); btn.innerText=text;
      if(text==="Fill Layer") btn.onclick=()=>{ for(let y=0;y<height;y++){ for(let x=0;x<width;x++){ paintTile(x,y); } } draw(); };
      if(text==="Clear Layer") btn.onclick=()=>{ for(let y=0;y<height;y++){ for(let x=0;x<width;x++){ mapData[currentLayer][y][x]=null; } } draw(); };
      if(text==="Export Map") btn.onclick=()=>{ 
        const json={width,height,layers:mapData,weather}; 
        const blob=new Blob([JSON.stringify(json,null,2)],{type:"application/json"}); 
        const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="map.json"; a.click(); 
      };
      if(text==="Load Map"){
        btn.onclick=()=>{ const input=document.createElement("input"); input.type="file"; input.accept=".json";
          input.onchange=e=>{ const file=e.target.files[0]; if(!file)return;
            const reader=new FileReader();
            reader.onload=evt=>{
              const json=JSON.parse(evt.target.result);
              canvas.width=json.width*TILE_SIZE; canvas.height=json.height*TILE_SIZE;
              const fillLayer=(layer)=>{ const newLayer=[]; for(let y=0;y<json.height;y++){ newLayer[y]=[]; for(let x=0;x<json.width;x++){ newLayer[y][x]=layer?.[y]?.[x]??null; } } return newLayer; };
              mapData.ground=fillLayer(json.layers.ground); mapData.groundAnim=fillLayer(json.layers.groundAnim);
              mapData.objects=fillLayer(json.layers.objects); mapData.objectAnim=fillLayer(json.layers.objectAnim);
              mapData.object2=fillLayer(json.layers.object2); mapData.object2Anim=fillLayer(json.layers.object2Anim);
              if(json.weather) weather=json.weather;
              draw();
            };
            reader.readAsText(file);
          };
          input.click();
        };
      }
      controlsDiv.appendChild(btn);
    });

    // --- Paint tile + draw ---
    function paintTile(x,y){
      const rows=selectedTiles.length,cols=selectedTiles[0].length;
      for(let ry=0;ry<rows;ry++){ for(let cx=0;cx<cols;cx++){
        const tileId=selectedTiles[ry][cx]; const px=x+cx,py=y+ry;
        if(px>=width||py>=height)continue;
        if(!mapData[currentLayer][py][px]) mapData[currentLayer][py][px]={tileId,tileset:currentTilesetIndex,attributes:{}};
        const tile=mapData[currentLayer][py][px];
        if(["groundAnim","objectAnim","object2Anim"].includes(currentLayer)){
          if(!Array.isArray(tile.tileId))tile.tileId=[tileId,tileId]; tile.tileset=currentTilesetIndex;
        } else tile.tileId=tileId, tile.tileset=currentTilesetIndex;
        tile.attributes={...currentAttributes};
        if(tile.attributes.walkable===undefined)tile.attributes.walkable=true;
        if((["objects","objectAnim","object2","object2Anim"].includes(currentLayer)) && tile.attributes.blocker===undefined) tile.attributes.blocker=false;
        if(currentAttributes.light) tile.attributes.light={color:lightSource.color,brightness:lightSource.brightness,flicker:lightSource.flicker,_last:lightSource.brightness};
        else delete tile.attributes.light;
      }}
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const renderOrder=["ground","groundAnim","objects","objectAnim","object2","object2Anim"];
      for(let y=0;y<height;y++){ 
          for(let x=0;x<width;x++){
              renderOrder.forEach(layerName=>{
                  const tile=mapData[layerName][y][x]; 
                  if(!tile) return;
                  const drawTileId=Array.isArray(tile.tileId)?tile.tileId[0]:tile.tileId;
                  const ts=tilesetImages[tile.tileset||0]; 
                  const tilesAcrossInImage=Math.floor(ts.width/TILE_SIZE);
                  const sx=(drawTileId%tilesAcrossInImage)*TILE_SIZE; 
                  const sy=Math.floor(drawTileId/tilesAcrossInImage)*TILE_SIZE;
                  ctx.drawImage(ts,sx,sy,TILE_SIZE,TILE_SIZE,x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);

                  if(tile.attributes){
                    if(tile.attributes.blocker) ctx.fillStyle="rgba(255,0,0,0.3)";
                    else if(tile.attributes.damage) ctx.fillStyle="rgba(255,165,0,0.3)";
                    else if(tile.attributes.healing) ctx.fillStyle="rgba(0,255,0,0.3)";
                    else if(tile.attributes.trigger) ctx.fillStyle="rgba(0,0,255,0.3)";
                    if(tile.attributes.blocker||tile.attributes.damage||tile.attributes.healing||tile.attributes.trigger)
                      ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);

                    if(tile.attributes.light){
                      const light=tile.attributes.light;
                      if(light._last===undefined)light._last=light.brightness;
                      light._last+=(Math.random()-0.5)*0.02;
                      light._last=Math.min(Math.max(light._last,0.7*light.brightness),1.0*light.brightness);
                      ctx.fillStyle=`rgba(${parseInt(light.color.slice(1,3),16)},${parseInt(light.color.slice(3,5),16)},${parseInt(light.color.slice(5,7),16)},${light._last})`;
                      ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
                    }
                  }
              });
          }
      }
      drawWeather();
      requestAnimationFrame(draw);
    }

    // --- Canvas painting ---
    let painting=false,erase=false;
    canvas.addEventListener("mousedown",e=>{painting=true;erase=(e.button===2);handleCanvasPaint(e);});
    canvas.addEventListener("mousemove",e=>{if(painting) handleCanvasPaint(e);});
    canvas.addEventListener("mouseup",()=>painting=false);
    canvas.addEventListener("mouseleave",()=>painting=false);
    canvas.addEventListener("contextmenu",e=>e.preventDefault());

    function handleCanvasPaint(e){
      const rect=canvas.getBoundingClientRect();
      const x=Math.floor((e.clientX-rect.left)/TILE_SIZE);
      const y=Math.floor((e.clientY-rect.top)/TILE_SIZE);
      if(x<0||y<0||x>=width||y>=height) return;
      const rows=selectedTiles.length,cols=selectedTiles[0].length;
      for(let ry=0;ry<rows;ry++){ for(let cx=0;cx<cols;cx++){
        const px=x+cx,py=y+ry; if(px>=width||py>=height) continue;
        if(erase) mapData[currentLayer][py][px]=null; else paintTile(px,py);
      }}
    }

    draw(); // start animation loop
  </script>
</body>
</html>
